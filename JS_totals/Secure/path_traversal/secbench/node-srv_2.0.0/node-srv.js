// Generated by CoffeeScript 1.11.1
(function() {
  var Server, _, fs, http, mime, minimatch, path, pkg, url;

  pkg = require('../package.json');

  fs = require('fs');

  _ = require('underscore');

  mime = require('mime');

  http = require('http');

  url = require('url');

  path = require('path');

  minimatch = require('minimatch');

  Server = (function() {
    Server.prototype.name = pkg.name;

    Server.prototype.version = pkg.version;

    Server.prototype.defaults = function() {
      return {
        port: 8000,
        host: '0.0.0.0',
        logs: false,
        index: 'index.html'
      };
    };

    function Server(options, exitCallback) {
      if (options == null) {
        options = {};
      }
      this.exitCallback = exitCallback;
      this.options = _.extend(this.defaults(), options);
      this._initLogs();
      this._bindCloseEvents();
      this.start();
    }

    Server.prototype.start = function() {
      return this.server = http.createServer(_.bind(this.request, this)).listen(Number(this.options.port), this.options.host);
    };

    Server.prototype.stop = function(callback) {
      var ref, ref1;
      if ((ref = this.server) != null) {
        ref.close();
      }
      if ((ref1 = this._loger) != null) {
        ref1.end();
      }
      if (typeof this.exitCallback === "function") {
        this.exitCallback();
      }
      return typeof callback === "function" ? callback() : void 0;
    };

    Server.prototype._bindCloseEvents = function() {
      var exit;
      exit = (function(_this) {
        return function() {
          process.removeAllListeners('SIGINT');
          process.removeAllListeners('SIGTERM');
          return _this.stop(function() {
            return process.exit();
          });
        };
      })(this);
      process.on('SIGINT', exit);
      return process.on('SIGTERM', exit);
    };

    Server.prototype._initLogs = function() {
      if (this.options.logs) {
        if (typeof this.options.logs === 'string') {
          return this._logger = fs.createWriteStream(this.options.logs, {
            flags: 'a'
          });
        } else {
          return this._log = console.log;
        }
      }
    };

    Server.prototype.request = function(req, res) {
      var filePath, headers, method, time;
      time = new Date();
      filePath = null;
      method = null;
      headers = null;
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var uri;
          uri = url.parse(req.url);
          return resolve(uri.pathname);
        };
      })(this)).then((function(_this) {
        return function(pathname) {
          var rootPath;
          rootPath = path.resolve(process.cwd(), _this.options.root || './');
          filePath = pathname;
          filePath = filePath.replace(/\/$/, "/" + _this.options.index);
          filePath = filePath.replace(/^\//, "");
          filePath = path.join(rootPath, filePath);
          if (filePath.indexOf(rootPath) !== 0) {
            throw {
              code: 400,
              message: "Bad URL: " + pathname
            };
          }
          method = req.method;
          headers = req.headers;
          return _this.processRequest(res, filePath, method, headers);
        };
      })(this), (function(_this) {
        return function(err) {
          return _this.errorCode(res, 400, "Message: " + err.message + "\nURL: " + req.url + "\n\n" + err.stack);
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          var ref;
          if (err.code === 'ENOENT') {
            return _this.handlerNotFound(res, err.path, method, headers);
          } else if ((ref = err.code) === 400 || ref === 405) {
            _this.log("[" + (time.toJSON()) + "] Error: " + err.message + ", Code: " + err.code);
            return _this.errorCode(res, 405, "Message: " + err.message + "\nCode: " + err.code);
          } else {
            _this.log("[" + (time.toJSON()) + "] Error: " + err.message + ", Code: " + err.code);
            return _this.errorCode(res, 500, "Message: " + err.message + "\nCode: " + err.code + "\n\n" + err.stack);
          }
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          _this.log("[" + (time.toJSON()) + "] Error: " + err.message);
          return _this.errorCode(res, 500, "Message: " + err.message + "\nCode: " + err.code + "\n\n" + err.stack);
        };
      })(this)).then((function(_this) {
        return function(code) {
          var host, log;
          host = path.join(req.headers.host || 'localhost:' + _this.options.port, req.url);
          log = "[" + (time.toJSON()) + "]";
          log += " (+" + (Date.now() - time) + "ms):";
          log += " " + code;
          log += " " + method;
          log += " " + host;
          if (filePath) {
            log += " - " + filePath;
          }
          if (req.headers['user-agent']) {
            log += " (" + req.headers['user-agent'] + ")";
          }
          return _this.log(log);
        };
      })(this));
    };

    Server.prototype.getHeaders = function(filePath) {
      var headers;
      headers = {
        "Server": this.name + "/" + this.version
      };
      if (filePath) {
        headers["Content-Type"] = mime.lookup(filePath);
      }
      return headers;
    };

    Server.prototype._parseRange = function(range, size) {
      var end, firstRangeStr, ref, start;
      if (range == null) {
        range = '';
      }
      if (size == null) {
        size = 0;
      }
      if (String(range).indexOf('bytes=') !== 0) {
        return null;
      }
      firstRangeStr = range.replace('bytes=', '').split(',')[0];
      if (!(firstRangeStr.indexOf('-') > -1)) {
        return null;
      }
      ref = firstRangeStr.split('-'), start = ref[0], end = ref[1];
      start = parseInt(start, 10);
      end = parseInt(end, 10);
      if (_.isNaN(start)) {
        start = size - end;
        end = size - 1;
      } else if (_.isNaN(end)) {
        end = size - 1;
      }
      if (end > size - 1) {
        end = size - 1;
      }
      if (_.isNaN(start) || _.isNaN(end) || start > end || start < 0) {
        return null;
      }
      return {
        start: start,
        end: end
      };
    };

    Server.prototype.fileStats = function(path) {
      return new Promise(function(resolve, reject) {
        return fs.stat(path, function(err, stats) {
          if (err) {
            return reject(err);
          }
          return resolve(stats);
        });
      });
    };

    Server.prototype.processRequest = function(res, filePath, method, headers) {
      var handler;
      if (handler = this.handle(filePath)) {
        return handler.call(this, res, filePath, method, headers);
      } else {
        return this.handlerStaticFile(res, filePath, method, headers);
      }
    };

    Server.prototype.handle = function(filePath) {
      var handlers, pattern;
      handlers = _.result(this, 'handlers');
      for (pattern in handlers) {
        if (minimatch(filePath, pattern)) {
          return handlers[pattern];
        }
      }
      return null;
    };

    Server.prototype.handlers = function() {
      return {};
    };

    Server.prototype.handlerStaticFile = function(res, filePath, method, reqHeaders) {
      var load;
      load = function(range, headers, successCode) {
        return new Promise(function(resolve, reject) {
          return fs.createReadStream(filePath, range).on('open', function() {
            return res.writeHead(successCode, headers);
          }).on('error', function(err) {
            return reject(err);
          }).on('data', function(data) {
            return res.write(data);
          }).on('end', function() {
            res.end();
            return resolve(successCode);
          });
        });
      };
      return Promise.resolve().then((function(_this) {
        return function() {
          return _this.fileStats(filePath);
        };
      })(this)).then((function(_this) {
        return function(stats) {
          var code, headers, range;
          range = _this._parseRange(reqHeaders['range'], stats.size);
          code = range ? 206 : 200;
          headers = _this.getHeaders(filePath);
          headers["Accept-Ranges"] = 'bytes';
          if (range) {
            headers['Content-Range'] = range.start + "-" + range.end + "/" + stats.size;
            headers['Content-Length'] = range.end - range.start;
          } else {
            headers['Content-Length'] = stats.size;
          }
          if (method === 'HEAD') {
            res.writeHead(code, headers);
            res.end();
            return code;
          } else if (method === 'GET') {
            return load(range, headers, code);
          } else {
            throw {
              code: 405,
              message: method + " method not allowed"
            };
          }
        };
      })(this));
    };

    Server.prototype.handlerNotFound = function(res, filePath, method, headers) {
      var code, errorPath, notFound;
      code = 404;
      notFound = (function(_this) {
        return function() {
          return _this.errorCode(res, code, "Path: " + filePath);
        };
      })(this);
      if (!this.options[code]) {
        return notFound();
      }
      errorPath = path.resolve(process.cwd(), this.options[code]);
      headers = _.extend(this.getHeaders(), {
        "Content-Type": "text/html"
      });
      if (method === 'HEAD') {
        res.writeHead(code, headers);
        res.end();
        return code;
      } else if (method === 'GET') {
        return new Promise((function(_this) {
          return function(resolve, reject) {
            return fs.createReadStream(errorPath).on('open', function() {
              return res.writeHead(code, headers);
            }).on('error', function(err) {
              return reject(err);
            }).on('data', function(data) {
              return res.write(data);
            }).on('end', function() {
              res.end();
              return resolve(code);
            });
          };
        })(this));
      } else {
        throw {
          code: 405,
          message: method + " method not allowed"
        };
      }
    };

    Server.prototype.errorCode = function(res, code, text) {
      if (text == null) {
        text = '';
      }
      if (text) {
        text = "<pre>" + text + "</pre>";
      }
      res.writeHead(code, _.extend(this.getHeaders(), {
        "Content-Type": "text/html"
      }));
      res.write(("<h1>" + code + " " + http.STATUS_CODES[code] + "</h1>") + text);
      res.end();
      return code;
    };

    Server.prototype.log = function(string) {
      var ref;
      if ((ref = this._logger) != null) {
        ref.write(string + '\n');
      }
      return typeof this._log === "function" ? this._log(string) : void 0;
    };

    return Server;

  })();

  module.exports = Server;

}).call(this);

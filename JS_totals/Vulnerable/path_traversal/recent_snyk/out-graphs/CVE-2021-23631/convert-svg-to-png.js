'use strict';
const fileUrl = require('file-url');
const fs = require('fs');
const path = require('path');
const puppeteer = require('puppeteer');
const tmp = require('tmp');
const util = require('util');
const v158 = fs.readFile;
const readFile = util.promisify(v158);
const v159 = fs.writeFile;
const writeFile = util.promisify(v159);
const _browser = Symbol('browser');
const _convert = Symbol('convert');
const _destroyed = Symbol('destroyed');
const _getDimensions = Symbol('getDimensions');
const _getPage = Symbol('getPage');
const _getTempFile = Symbol('getTempFile');
const _options = Symbol('options');
const _page = Symbol('page');
const _parseOptions = Symbol('parseOptions');
const _provider = Symbol('provider');
const _setDimensions = Symbol('setDimensions');
const _tempFile = Symbol('tempFile');
const _validate = Symbol('validate');
const Converter = function Converter(provider, options) {
    this[_provider] = provider;
    const v160 = {};
    const v161 = Object.assign(v160, options);
    this[_options] = v161;
    this[_destroyed] = false;
};
const convert = async function convert(input, options) {
    const v162 = this[_validate]();
    v162;
    options = this[_parseOptions](options);
    const output = await this[_convert](input, options);
    return output;
};
Converter.convert = convert;
const convertFile = async function convertFile(inputFilePath, options) {
    const v163 = this[_validate]();
    v163;
    options = this[_parseOptions](options, inputFilePath);
    const input = await readFile(inputFilePath);
    const output = await this[_convert](input, options);
    const v164 = options.outputFilePath;
    await writeFile(v164, output);
    const v165 = options.outputFilePath;
    return v165;
};
Converter.convertFile = convertFile;
const destroy = async function destroy() {
    const v166 = this[_destroyed];
    if (v166) {
        return;
    }
    this[_destroyed] = true;
    const v167 = this[_tempFile];
    if (v167) {
        const v168 = this[_tempFile];
        const v169 = v168.cleanup();
        v169;
        const v170 = this[_tempFile];
        const v171 = delete v170;
        v171;
    }
    const v172 = this[_browser];
    if (v172) {
        const v173 = this[_browser];
        await v173.close();
        const v174 = this[_browser];
        const v175 = delete v174;
        v175;
        const v176 = this[_page];
        const v177 = delete v176;
        v177;
    }
};
Converter.destroy = destroy;
const _convert = async function _convert(input, options) {
    const v178 = Buffer.isBuffer(input);
    const v179 = input.toString('utf8');
    if (v178) {
        input = v179;
    } else {
        input = input;
    }
    const v180 = this;
    const provider = v180.provider;
    const start = input.indexOf('<svg');
    const v181 = options.baseUrl;
    const v182 = provider.getBackgroundColor(options);
    let html = `<!DOCTYPE html>
<base href="${ v181 }">
<style>
* { margin: 0; padding: 0; }
html { background-color: ${ v182 }; }
</style>`;
    const v183 = start >= 0;
    if (v183) {
        html += input.substring(start);
    } else {
        const v184 = new Error('SVG element open tag not found in input. Check the SVG input');
        throw v184;
    }
    const page = await this[_getPage](html);
    await this[_setDimensions](page, options);
    const dimensions = await this[_getDimensions](page);
    const v185 = !dimensions;
    if (v185) {
        const v186 = new Error('Unable to derive width and height from SVG. Consider specifying corresponding options');
        throw v186;
    }
    const v187 = options.scale;
    const v188 = v187 !== 1;
    if (v188) {
        const v189 = options.scale;
        dimensions.height *= v189;
        const v190 = options.scale;
        dimensions.width *= v190;
        await this[_setDimensions](page, dimensions);
    }
    const v191 = dimensions.height;
    const v192 = Math.round(v191);
    const v193 = dimensions.width;
    const v194 = Math.round(v193);
    const v195 = {
        height: v192,
        width: v194
    };
    await page.setViewport(v195);
    const v196 = provider.getType();
    const v197 = {
        x: 0,
        y: 0
    };
    const v198 = Object.assign(v197, dimensions);
    const v199 = {
        type: v196,
        clip: v198
    };
    const v200 = provider.getScreenshotOptions(options);
    const v201 = Object.assign(v199, v200);
    const output = await page.screenshot(v201);
    return output;
};
Converter._convert = _convert;
const _getDimensions = function _getDimensions(page) {
    const v227 = () => {
        const el = document.querySelector('svg');
        const v202 = !el;
        if (v202) {
            return null;
        }
        const v203 = el.getAttribute('width');
        const v204 = v203 || '';
        const widthIsPercent = v204.endsWith('%');
        const v205 = el.getAttribute('height');
        const v206 = v205 || '';
        const heightIsPercent = v206.endsWith('%');
        const v207 = !widthIsPercent;
        const v208 = el.getAttribute('width');
        const v209 = parseFloat(v208);
        const width = v207 && v209;
        const v210 = !heightIsPercent;
        const v211 = el.getAttribute('height');
        const v212 = parseFloat(v211);
        const height = v210 && v212;
        const v213 = width && height;
        if (v213) {
            const v214 = {};
            v214.width = width;
            v214.height = height;
            return v214;
        }
        const v215 = el.viewBox;
        const v216 = v215.animVal;
        const viewBoxWidth = v216.width;
        const v217 = el.viewBox;
        const v218 = v217.animVal;
        const viewBoxHeight = v218.height;
        const v219 = width && viewBoxHeight;
        if (v219) {
            const v220 = width * viewBoxHeight;
            const v221 = v220 / viewBoxWidth;
            const v222 = {};
            v222.width = width;
            v222.height = v221;
            return v222;
        }
        const v223 = height && viewBoxWidth;
        if (v223) {
            const v224 = height * viewBoxWidth;
            const v225 = v224 / viewBoxHeight;
            const v226 = {};
            v226.width = v225;
            v226.height = height;
            return v226;
        }
        return null;
    };
    const v228 = page.evaluate(v227);
    return v228;
};
Converter._getDimensions = _getDimensions;
const _getPage = async function _getPage(html) {
    const v229 = this[_browser];
    const v230 = !v229;
    if (v230) {
        const v231 = this[_options];
        const v232 = v231.puppeteer;
        this[_browser] = await puppeteer.launch(v232);
        const v233 = this[_browser];
        this[_page] = await v233.newPage();
    }
    const tempFile = await this[_getTempFile]();
    const v234 = tempFile.path;
    await writeFile(v234, html);
    const v235 = this[_page];
    const v236 = tempFile.path;
    const v237 = fileUrl(v236);
    await v235.goto(v237);
    const v238 = this[_page];
    return v238;
};
Converter._getPage = _getPage;
const _getTempFile = function _getTempFile() {
    const v239 = this[_tempFile];
    if (v239) {
        const v240 = this[_tempFile];
        const v241 = Promise.resolve(v240);
        return v241;
    }
    const v249 = (resolve, reject) => {
        const v242 = {
            prefix: 'convert-svg-',
            postfix: '.html'
        };
        const v247 = (error, filePath, fd, cleanup) => {
            if (error) {
                const v243 = reject(error);
                v243;
            } else {
                const v244 = {};
                v244.path = filePath;
                v244.cleanup = cleanup;
                this[_tempFile] = v244;
                const v245 = this[_tempFile];
                const v246 = resolve(v245);
                v246;
            }
        };
        const v248 = tmp.file(v242, v247);
        v248;
    };
    const v250 = new Promise(v249);
    return v250;
};
Converter._getTempFile = _getTempFile;
const _parseOptions = function _parseOptions(options, inputFilePath) {
    const v251 = {};
    options = Object.assign(v251, options);
    const v252 = this;
    const provider = v252.provider;
    const v253 = options.outputFilePath;
    const v254 = !v253;
    const v255 = v254 && inputFilePath;
    if (v255) {
        const v256 = provider.getExtension();
        const extension = `.${ v256 }`;
        const outputDirPath = path.dirname(inputFilePath);
        const v257 = path.extname(inputFilePath);
        const v258 = path.basename(inputFilePath, v257);
        const outputFileName = `${ v258 }${ extension }`;
        const v259 = path.join(outputDirPath, outputFileName);
        options.outputFilePath = v259;
    }
    const v260 = options.baseFile;
    const v261 = v260 != null;
    const v262 = options.baseUrl;
    const v263 = v262 != null;
    const v264 = v261 && v263;
    if (v264) {
        const v265 = new Error('Both baseFile and baseUrl options specified. Use only one');
        throw v265;
    }
    const v266 = options.baseFile;
    const v267 = typeof v266;
    const v268 = v267 === 'string';
    if (v268) {
        const v269 = options.baseFile;
        const v270 = fileUrl(v269);
        options.baseUrl = v270;
        const v271 = options.baseFile;
        const v272 = delete v271;
        v272;
    }
    const v273 = options.baseUrl;
    const v274 = !v273;
    if (v274) {
        const v275 = path.resolve(inputFilePath);
        const v276 = process.cwd();
        let v277;
        if (inputFilePath) {
            v277 = v275;
        } else {
            v277 = v276;
        }
        const v278 = fileUrl(v277);
        options.baseUrl = v278;
    }
    const v279 = options.height;
    const v280 = typeof v279;
    const v281 = v280 === 'string';
    if (v281) {
        const v282 = options.height;
        const v283 = parseInt(v282, 10);
        options.height = v283;
    }
    const v284 = options.scale;
    const v285 = v284 == null;
    if (v285) {
        options.scale = 1;
    }
    const v286 = options.width;
    const v287 = typeof v286;
    const v288 = v287 === 'string';
    if (v288) {
        const v289 = options.width;
        const v290 = parseInt(v289, 10);
        options.width = v290;
    }
    const v291 = provider.parseAPIOptions(options, inputFilePath);
    v291;
    return options;
};
Converter._parseOptions = _parseOptions;
const _setDimensions = async function _setDimensions(page, dimensions) {
    const v292 = dimensions.width;
    const v293 = typeof v292;
    const v294 = v293 !== 'number';
    const v295 = dimensions.height;
    const v296 = typeof v295;
    const v297 = v296 !== 'number';
    const v298 = v294 && v297;
    if (v298) {
        return;
    }
    const v310 = ({width, height}) => {
        const el = document.querySelector('svg');
        const v299 = !el;
        if (v299) {
            return;
        }
        const v300 = typeof width;
        const v301 = v300 === 'number';
        if (v301) {
            const v302 = `${ width }px`;
            const v303 = el.setAttribute('width', v302);
            v303;
        } else {
            const v304 = el.removeAttribute('width');
            v304;
        }
        const v305 = typeof height;
        const v306 = v305 === 'number';
        if (v306) {
            const v307 = `${ height }px`;
            const v308 = el.setAttribute('height', v307);
            v308;
        } else {
            const v309 = el.removeAttribute('height');
            v309;
        }
    };
    await page.evaluate(v310, dimensions);
};
Converter._setDimensions = _setDimensions;
const _validate = function _validate() {
    const v311 = this[_destroyed];
    if (v311) {
        const v312 = new Error('Converter has been destroyed. A new Converter must be created');
        throw v312;
    }
};
Converter._validate = _validate;
const destroyed = function destroyed() {
    const v313 = this[_destroyed];
    return v313;
};
Converter.destroyed = destroyed;
const provider = function provider() {
    const v314 = this[_provider];
    return v314;
};
Converter.provider = provider;
Converter['is_class'] = true;
module.exports = Converter;
'use strict';
const childProcess = require('child_process');
const path = require('path');
const fs = require('fs');
const processWrapper = require('./process-wrapper');
const supportedPlatforms = [
    'win32',
    'linux',
    'darwin'
];
const nodeModulesDirName = 'node_modules';
const getNpmExecutable = platform => {
    let npmExecutableName = 'npm';
    const v73 = platform === 'win32';
    if (v73) {
        npmExecutableName += '.cmd';
    }
    return npmExecutableName;
};
const getNpmPrefix = pathToNpm => {
    try {
        const v74 = `${ pathToNpm } config get prefix`;
        const npmPrefixStdout = childProcess.execSync(v74);
        const v75 = npmPrefixStdout.toString();
        const v76 = v75.trim();
        const v77 = npmPrefixStdout && v76;
        return v77;
    } catch (err) {
        const v78 = err.message;
        const v79 = console.error(v78);
        v79;
    }
    return null;
};
const getPathFromNpmConfig = (platform, packageName) => {
    const pathToNpm = getNpmExecutable(platform);
    const npmConfigPrefix = getNpmPrefix(pathToNpm);
    if (npmConfigPrefix) {
        let nodeModulesPath = path.join(npmConfigPrefix, nodeModulesDirName);
        const v80 = platform !== 'win32';
        if (v80) {
            nodeModulesPath = path.join(npmConfigPrefix, 'lib', nodeModulesDirName);
        }
        const packagePath = path.join(nodeModulesPath, packageName);
        const verifiedPath = getVerifiedPath(packagePath, packageName);
        if (verifiedPath) {
            return verifiedPath;
        }
    }
    return null;
};
const getPathFromCmdContent = (packageName, pathToExecutable) => {
    const v81 = fs.existsSync(pathToExecutable);
    if (v81) {
        const v82 = fs.readFileSync(pathToExecutable);
        const executableContent = v82.toString();
        let fullPath;
        let windowsPathRegExp = /(%~dp0[\w\\.-]+node_modules).*?"/g;
        let match = windowsPathRegExp.exec(executableContent);
        const v83 = match[1];
        const v84 = match && v83;
        if (v84) {
            const v85 = match[1];
            const v86 = path.dirname(pathToExecutable);
            const v87 = v85.replace('%~dp0', v86);
            const realPath = path.normalize(v87);
            fullPath = path.join(realPath, packageName);
        }
        const v88 = !fullPath;
        if (v88) {
            windowsPathRegExp = new RegExp(`(%~dp0[\\w\\\\.-]+?${ packageName })(?:\\\\|")`, 'g');
            match = windowsPathRegExp.exec(executableContent);
            const v89 = match[1];
            const v90 = match && v89;
            if (v90) {
                const v91 = match[1];
                const v92 = path.dirname(pathToExecutable);
                const v93 = v91.replace('%~dp0', v92);
                fullPath = path.normalize(v93);
            }
        }
        if (fullPath) {
            const pathToPackage = getVerifiedPath(fullPath, packageName);
            if (pathToPackage) {
                return pathToPackage;
            }
        }
    }
};
const getVerifiedPath = (suggestedPath, packageName) => {
    const pathToPackageJson = path.join(suggestedPath, 'package.json');
    const v94 = fs.existsSync(suggestedPath);
    const v95 = fs.existsSync(pathToPackageJson);
    const v96 = v94 && v95;
    if (v96) {
        try {
            const v97 = fs.readFileSync(pathToPackageJson);
            const packageJsonContent = JSON.parse(v97);
            const v98 = packageJsonContent.name;
            const v99 = v98 === packageName;
            if (v99) {
                return suggestedPath;
            }
        } catch (err) {
        }
    }
};
const getPathFromExecutableNameOnWindows = (packageName, executableName) => {
    try {
        const v100 = `where ${ executableName }`;
        const v101 = childProcess.execSync(v100);
        const v102 = v101 || '';
        const v103 = v102.toString();
        const whereResult = v103.split('\n');
        let line;
        for (line of whereResult) {
            const v104 = line.trim();
            const pathToExecutable = line && v104;
            if (pathToExecutable) {
                const v105 = path.dirname(pathToExecutable);
                const pathToLib = path.join(v105, nodeModulesDirName, packageName);
                const verifiedPath = getVerifiedPath(pathToLib, packageName);
                if (verifiedPath) {
                    return verifiedPath;
                }
                const pathToExecutableFromContent = getPathFromCmdContent(packageName, pathToExecutable);
                if (pathToExecutableFromContent) {
                    return pathToExecutableFromContent;
                }
                const resolvedPath = getPathWhenExecutableIsAddedDirectlyToPath(packageName, pathToExecutable);
                if (resolvedPath) {
                    return resolvedPath;
                }
            }
        }
    } catch (err) {
        const v106 = err.message;
        const v107 = console.error(v106);
        v107;
    }
    return null;
};
const getPathFromExecutableNameOnNonWindows = (packageName, executableName) => {
    try {
        const v108 = `which ${ executableName }`;
        const v109 = childProcess.execSync(v108);
        const v110 = v109 || '';
        const v111 = v110.toString();
        const whichResult = v111.trim();
        const v112 = `ls -l \`which ${ executableName }\``;
        const v113 = childProcess.execSync(v112);
        const v114 = v113 || '';
        const v115 = v114.toString();
        const lsLResult = v115.trim();
        const v116 = whichResult && lsLResult;
        if (v116) {
            const regex = new RegExp(`${ whichResult }\\s+->\\s+(.*?)$`);
            const match = lsLResult.match(regex);
            const v117 = match[1];
            const v118 = match && v117;
            if (v118) {
                const v119 = path.dirname(whichResult);
                const v120 = match[1];
                const v121 = path.join(v119, v120);
                const pathToRealExecutable = fs.realpathSync(v121);
                const v122 = path.join(nodeModulesDirName, packageName);
                const v123 = new RegExp(`(.*?${ v122 }).*$`);
                const packagePathMatch = pathToRealExecutable.match(v123);
                if (packagePathMatch) {
                    const v124 = packagePathMatch[1];
                    const verifiedPath = getVerifiedPath(v124, packageName);
                    if (verifiedPath) {
                        return verifiedPath;
                    }
                }
            }
            const v125 = getPathWhenExecutableIsAddedDirectlyToPath(packageName, whichResult);
            return v125;
        }
    } catch (err) {
        const v126 = err.message;
        const v127 = console.error(v126);
        v127;
    }
    return null;
};
const getPathWhenExecutableIsAddedDirectlyToPath = (packageName, executablePath) => {
    const v128 = path.dirname(executablePath);
    const pathToPackageJson = path.join(v128, '..', 'package.json');
    const v129 = fs.existsSync(pathToPackageJson);
    if (v129) {
        const v130 = fs.readFileSync(pathToPackageJson);
        const v131 = JSON.parse(v130);
        const packageNameFromPackageJson = v131.name;
        const v132 = packageNameFromPackageJson === packageName;
        if (v132) {
            const v133 = path.dirname(pathToPackageJson);
            return v133;
        }
    }
    return null;
};
const getPath = (packageName, executableName) => {
    const platform = processWrapper.getProcessPlatform();
    const v134 = supportedPlatforms.indexOf(platform);
    const v135 = -1;
    const v136 = v134 === v135;
    if (v136) {
        const v137 = new Error(`OS '${ platform }' is not supported.'`);
        throw v137;
    }
    let foundPath = null;
    if (executableName) {
        const v138 = platform === 'win32';
        const v139 = getPathFromExecutableNameOnWindows(packageName, executableName);
        const v140 = getPathFromExecutableNameOnNonWindows(packageName, executableName);
        if (v138) {
            foundPath = v139;
        } else {
            foundPath = v140;
        }
    }
    const v141 = !foundPath;
    if (v141) {
        foundPath = getPathFromNpmConfig(platform, packageName);
    }
    if (foundPath) {
        try {
            foundPath = fs.realpathSync(foundPath);
        } catch (err) {
            const v142 = err.message;
            const v143 = console.error(v142);
            v143;
        }
    }
    return foundPath;
};
const v144 = {};
v144.getPath = getPath;
module.exports = v144;
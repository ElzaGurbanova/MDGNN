'use strict';
const childProcess = require('child_process');
const path = require('path');
const fs = require('fs');
const processWrapper = require('./process-wrapper');
const supportedPlatforms = [
    'win32',
    'linux',
    'darwin'
];
const nodeModulesDirName = 'node_modules';
const getNpmExecutable = platform => {
    let npmExecutableName = 'npm';
    const v72 = platform === 'win32';
    if (v72) {
        npmExecutableName += '.cmd';
    }
    return npmExecutableName;
};
const spawnSyncWrapper = (command, commandArgs) => {
    const result = childProcess.spawnSync(command, commandArgs);
    const v73 = !result;
    if (v73) {
        return null;
    }
    const v74 = result.error;
    if (v74) {
        const v75 = result.error;
        throw v75;
    }
    const v76 = result.stdout;
    if (v76) {
        const v77 = result.stdout;
        const v78 = v77.toString();
        const v79 = v78.trim();
        return v79;
    }
    return null;
};
const getNpmPrefix = pathToNpm => {
    try {
        const v80 = [
            'config',
            'get',
            'prefix'
        ];
        const npmPrefixStdout = spawnSyncWrapper(pathToNpm, v80);
        const v81 = npmPrefixStdout.toString();
        const v82 = v81.trim();
        const v83 = npmPrefixStdout && v82;
        return v83;
    } catch (err) {
        const v84 = err.message;
        const v85 = console.error(v84);
        v85;
    }
    return null;
};
const getPathFromNpmConfig = (platform, packageName) => {
    const pathToNpm = getNpmExecutable(platform);
    const npmConfigPrefix = getNpmPrefix(pathToNpm);
    if (npmConfigPrefix) {
        let nodeModulesPath = path.join(npmConfigPrefix, nodeModulesDirName);
        const v86 = platform !== 'win32';
        if (v86) {
            nodeModulesPath = path.join(npmConfigPrefix, 'lib', nodeModulesDirName);
        }
        const packagePath = path.join(nodeModulesPath, packageName);
        const verifiedPath = getVerifiedPath(packagePath, packageName);
        if (verifiedPath) {
            return verifiedPath;
        }
    }
    return null;
};
const getPathFromCmdContent = (packageName, pathToExecutable) => {
    const v87 = fs.existsSync(pathToExecutable);
    if (v87) {
        const v88 = fs.readFileSync(pathToExecutable);
        const executableContent = v88.toString();
        let fullPath;
        let windowsPathRegExp = /(%~dp0[\w\\.-]+node_modules).*?"/g;
        let match = windowsPathRegExp.exec(executableContent);
        const v89 = match[1];
        const v90 = match && v89;
        if (v90) {
            const v91 = match[1];
            const v92 = path.dirname(pathToExecutable);
            const v93 = v91.replace('%~dp0', v92);
            const realPath = path.normalize(v93);
            fullPath = path.join(realPath, packageName);
        }
        const v94 = !fullPath;
        if (v94) {
            windowsPathRegExp = new RegExp(`(%~dp0[\\w\\\\.-]+?${ packageName })(?:\\\\|")`, 'g');
            match = windowsPathRegExp.exec(executableContent);
            const v95 = match[1];
            const v96 = match && v95;
            if (v96) {
                const v97 = match[1];
                const v98 = path.dirname(pathToExecutable);
                const v99 = v97.replace('%~dp0', v98);
                fullPath = path.normalize(v99);
            }
        }
        if (fullPath) {
            const pathToPackage = getVerifiedPath(fullPath, packageName);
            if (pathToPackage) {
                return pathToPackage;
            }
        }
    }
};
const getVerifiedPath = (suggestedPath, packageName) => {
    const pathToPackageJson = path.join(suggestedPath, 'package.json');
    const v100 = fs.existsSync(suggestedPath);
    const v101 = fs.existsSync(pathToPackageJson);
    const v102 = v100 && v101;
    if (v102) {
        try {
            const v103 = fs.readFileSync(pathToPackageJson);
            const packageJsonContent = JSON.parse(v103);
            const v104 = packageJsonContent.name;
            const v105 = v104 === packageName;
            if (v105) {
                return suggestedPath;
            }
        } catch (err) {
        }
    }
};
const getPathFromExecutableNameOnWindows = (packageName, executableName) => {
    try {
        const v106 = spawnSyncWrapper('where', executableName);
        const v107 = v106 || '';
        const whereResult = v107.split('\n');
        let line;
        for (line of whereResult) {
            const v108 = line.trim();
            const pathToExecutable = line && v108;
            if (pathToExecutable) {
                const v109 = path.dirname(pathToExecutable);
                const pathToLib = path.join(v109, nodeModulesDirName, packageName);
                const verifiedPath = getVerifiedPath(pathToLib, packageName);
                if (verifiedPath) {
                    return verifiedPath;
                }
                const pathToExecutableFromContent = getPathFromCmdContent(packageName, pathToExecutable);
                if (pathToExecutableFromContent) {
                    return pathToExecutableFromContent;
                }
                const resolvedPath = getPathWhenExecutableIsAddedDirectlyToPath(packageName, pathToExecutable);
                if (resolvedPath) {
                    return resolvedPath;
                }
            }
        }
    } catch (err) {
        const v110 = err.message;
        const v111 = console.error(v110);
        v111;
    }
    return null;
};
const getPathFromExecutableNameOnNonWindows = (packageName, executableName) => {
    try {
        const v112 = [executableName];
        const whichResult = spawnSyncWrapper('which', v112);
        const v113 = [
            '-l',
            whichResult
        ];
        const lsLResult = spawnSyncWrapper('ls', v113);
        const v114 = whichResult && lsLResult;
        if (v114) {
            const regex = new RegExp(`${ whichResult }\\s+->\\s+(.*?)$`);
            const match = lsLResult.match(regex);
            const v115 = match[1];
            const v116 = match && v115;
            if (v116) {
                const v117 = path.dirname(whichResult);
                const v118 = match[1];
                const v119 = path.join(v117, v118);
                const pathToRealExecutable = fs.realpathSync(v119);
                const v120 = path.join(nodeModulesDirName, packageName);
                const v121 = new RegExp(`(.*?${ v120 }).*$`);
                const packagePathMatch = pathToRealExecutable.match(v121);
                if (packagePathMatch) {
                    const v122 = packagePathMatch[1];
                    const verifiedPath = getVerifiedPath(v122, packageName);
                    if (verifiedPath) {
                        return verifiedPath;
                    }
                }
            }
            const v123 = getPathWhenExecutableIsAddedDirectlyToPath(packageName, whichResult);
            return v123;
        }
    } catch (err) {
        const v124 = err.message;
        const v125 = console.error(v124);
        v125;
    }
    return null;
};
const getPathWhenExecutableIsAddedDirectlyToPath = (packageName, executablePath) => {
    const v126 = path.dirname(executablePath);
    const pathToPackageJson = path.join(v126, '..', 'package.json');
    const v127 = fs.existsSync(pathToPackageJson);
    if (v127) {
        const v128 = fs.readFileSync(pathToPackageJson);
        const v129 = JSON.parse(v128);
        const packageNameFromPackageJson = v129.name;
        const v130 = packageNameFromPackageJson === packageName;
        if (v130) {
            const v131 = path.dirname(pathToPackageJson);
            return v131;
        }
    }
    return null;
};
const getPath = (packageName, executableName) => {
    const platform = processWrapper.getProcessPlatform();
    const v132 = supportedPlatforms.indexOf(platform);
    const v133 = -1;
    const v134 = v132 === v133;
    if (v134) {
        const v135 = new Error(`OS '${ platform }' is not supported.'`);
        throw v135;
    }
    let foundPath = null;
    if (executableName) {
        const v136 = platform === 'win32';
        const v137 = getPathFromExecutableNameOnWindows(packageName, executableName);
        const v138 = getPathFromExecutableNameOnNonWindows(packageName, executableName);
        if (v136) {
            foundPath = v137;
        } else {
            foundPath = v138;
        }
    }
    const v139 = !foundPath;
    if (v139) {
        foundPath = getPathFromNpmConfig(platform, packageName);
    }
    if (foundPath) {
        try {
            foundPath = fs.realpathSync(foundPath);
        } catch (err) {
            const v140 = err.message;
            const v141 = console.error(v140);
            v141;
        }
    }
    return foundPath;
};
const v142 = {};
v142.getPath = getPath;
module.exports = v142;
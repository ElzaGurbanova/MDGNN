'use strict';
const cheerio = require('cheerio');
const fileUrl = require('file-url');
const fs = require('fs');
const path = require('path');
const puppeteer = require('puppeteer');
const tmp = require('tmp');
const util = require('util');
const v167 = fs.readFile;
const readFile = util.promisify(v167);
const v168 = fs.writeFile;
const writeFile = util.promisify(v168);
const _browser = Symbol('browser');
const _convert = Symbol('convert');
const _destroyed = Symbol('destroyed');
const _getDimensions = Symbol('getDimensions');
const _getPage = Symbol('getPage');
const _getTempFile = Symbol('getTempFile');
const _options = Symbol('options');
const _page = Symbol('page');
const _parseOptions = Symbol('parseOptions');
const _provider = Symbol('provider');
const _roundDimension = Symbol('roundDimension');
const _roundDimensions = Symbol('roundDimensions');
const _setDimensions = Symbol('setDimensions');
const _tempFile = Symbol('tempFile');
const _validate = Symbol('validate');
const Converter = function Converter(provider, options) {
    this[_provider] = provider;
    const v169 = {};
    const v170 = Object.assign(v169, options);
    this[_options] = v170;
    this[_destroyed] = false;
};
const convert = async function convert(input, options) {
    const v171 = this[_validate]();
    v171;
    options = this[_parseOptions](options);
    const output = await this[_convert](input, options);
    return output;
};
Converter.convert = convert;
const convertFile = async function convertFile(inputFilePath, options) {
    const v172 = this[_validate]();
    v172;
    options = this[_parseOptions](options, inputFilePath);
    const input = await readFile(inputFilePath);
    const output = await this[_convert](input, options);
    const v173 = options.outputFilePath;
    await writeFile(v173, output);
    const v174 = options.outputFilePath;
    return v174;
};
Converter.convertFile = convertFile;
const destroy = async function destroy() {
    const v175 = this[_destroyed];
    if (v175) {
        return;
    }
    this[_destroyed] = true;
    const v176 = this[_tempFile];
    if (v176) {
        const v177 = this[_tempFile];
        const v178 = v177.cleanup();
        v178;
        const v179 = this[_tempFile];
        const v180 = delete v179;
        v180;
    }
    const v181 = this[_browser];
    if (v181) {
        const v182 = this[_browser];
        await v182.close();
        const v183 = this[_browser];
        const v184 = delete v183;
        v184;
        const v185 = this[_page];
        const v186 = delete v185;
        v186;
    }
};
Converter.destroy = destroy;
const _convert = async function _convert(input, options) {
    const v187 = Buffer.isBuffer(input);
    const v188 = input.toString('utf8');
    if (v187) {
        input = v188;
    } else {
        input = input;
    }
    const v189 = this;
    const provider = v189.provider;
    const v190 = cheerio.load(input, null, false);
    const v191 = v190('svg');
    const svg = cheerio.html(v191);
    let html = '';
    if (svg) {
        const v192 = options.baseUrl;
        const v193 = provider.getBackgroundColor(options);
        html += `<!DOCTYPE html>
<html>
<head>
<base href="${ v192 }">
<meta charset="utf-8">
<style>
* { margin: 0; padding: 0; }
html { background-color: ${ v193 }; }
</style>
</head>
<body>${ svg }</body>
</html>`;
    } else {
        const v194 = new Error('SVG element not found in input. Check the SVG input');
        throw v194;
    }
    const page = await this[_getPage](html);
    await this[_setDimensions](page, options);
    const dimensions = await this[_getDimensions](page, options);
    const v195 = options.scale;
    const v196 = v195 !== 1;
    if (v196) {
        const v197 = options.scale;
        dimensions.height *= v197;
        const v198 = options.scale;
        dimensions.width *= v198;
        await this[_setDimensions](page, dimensions);
    }
    await page.setViewport(dimensions);
    const v199 = provider.getType();
    const v200 = {
        x: 0,
        y: 0
    };
    const v201 = Object.assign(v200, dimensions);
    const v202 = {
        type: v199,
        clip: v201
    };
    const v203 = provider.getScreenshotOptions(options);
    const v204 = Object.assign(v202, v203);
    const output = await page.screenshot(v204);
    return output;
};
Converter._convert = _convert;
const _getDimensions = async function _getDimensions(page, options) {
    const v226 = () => {
        const el = document.querySelector('svg');
        const v205 = !el;
        if (v205) {
            return null;
        }
        const parseAttributeDimension = function (attributeName) {
            const attributeValue = el.getAttribute(attributeName);
            const v206 = !attributeValue;
            const v207 = attributeValue.endsWith('%');
            const v208 = v206 || v207;
            if (v208) {
                return null;
            }
            const dimension = parseFloat(attributeValue);
            const v209 = Number.isNaN(dimension);
            if (v209) {
                return null;
            }
            const v210 = attributeValue.endsWith('pt');
            if (v210) {
                const v211 = dimension * 1.33333;
                return v211;
            }
            return dimension;
        };
        const width = parseAttributeDimension('width');
        const height = parseAttributeDimension('height');
        const v212 = width && height;
        if (v212) {
            const v213 = {};
            v213.width = width;
            v213.height = height;
            return v213;
        }
        const v214 = el.viewBox;
        const v215 = v214.animVal;
        const viewBoxWidth = v215.width;
        const v216 = el.viewBox;
        const v217 = v216.animVal;
        const viewBoxHeight = v217.height;
        const v218 = width && viewBoxHeight;
        if (v218) {
            const v219 = width * viewBoxHeight;
            const v220 = v219 / viewBoxWidth;
            const v221 = {};
            v221.width = width;
            v221.height = v220;
            return v221;
        }
        const v222 = height && viewBoxWidth;
        if (v222) {
            const v223 = height * viewBoxWidth;
            const v224 = v223 / viewBoxHeight;
            const v225 = {};
            v225.width = v224;
            v225.height = height;
            return v225;
        }
        return null;
    };
    const dimensions = await page.evaluate(v226);
    const v227 = !dimensions;
    if (v227) {
        const v228 = new Error('Unable to derive width and height from SVG. Consider specifying corresponding options');
        throw v228;
    }
    const v229 = options.rounding;
    const v230 = this[_roundDimensions](dimensions, v229);
    return v230;
};
Converter._getDimensions = _getDimensions;
const _getPage = async function _getPage(html) {
    const v231 = this[_browser];
    const v232 = !v231;
    if (v232) {
        const v233 = this[_options];
        const v234 = v233.puppeteer;
        this[_browser] = await puppeteer.launch(v234);
        const v235 = this[_browser];
        this[_page] = await v235.newPage();
    }
    const tempFile = await this[_getTempFile]();
    const v236 = tempFile.path;
    await writeFile(v236, html);
    const v237 = this[_page];
    const v238 = tempFile.path;
    const v239 = fileUrl(v238);
    await v237.goto(v239);
    const v240 = this[_page];
    return v240;
};
Converter._getPage = _getPage;
const _getTempFile = function _getTempFile() {
    const v241 = this[_tempFile];
    if (v241) {
        const v242 = this[_tempFile];
        const v243 = Promise.resolve(v242);
        return v243;
    }
    const v251 = (resolve, reject) => {
        const v244 = {
            prefix: 'convert-svg-',
            postfix: '.html'
        };
        const v249 = (error, filePath, fd, cleanup) => {
            if (error) {
                const v245 = reject(error);
                v245;
            } else {
                const v246 = {};
                v246.path = filePath;
                v246.cleanup = cleanup;
                this[_tempFile] = v246;
                const v247 = this[_tempFile];
                const v248 = resolve(v247);
                v248;
            }
        };
        const v250 = tmp.file(v244, v249);
        v250;
    };
    const v252 = new Promise(v251);
    return v252;
};
Converter._getTempFile = _getTempFile;
const _parseOptions = function _parseOptions(options, inputFilePath) {
    const v253 = {};
    options = Object.assign(v253, options);
    const v254 = this;
    const provider = v254.provider;
    const v255 = options.outputFilePath;
    const v256 = !v255;
    const v257 = v256 && inputFilePath;
    if (v257) {
        const v258 = provider.getExtension();
        const extension = `.${ v258 }`;
        const outputDirPath = path.dirname(inputFilePath);
        const v259 = path.extname(inputFilePath);
        const v260 = path.basename(inputFilePath, v259);
        const outputFileName = `${ v260 }${ extension }`;
        const v261 = path.join(outputDirPath, outputFileName);
        options.outputFilePath = v261;
    }
    const v262 = options.baseFile;
    const v263 = v262 != null;
    const v264 = options.baseUrl;
    const v265 = v264 != null;
    const v266 = v263 && v265;
    if (v266) {
        const v267 = new Error('Both baseFile and baseUrl options specified. Use only one');
        throw v267;
    }
    const v268 = options.baseFile;
    const v269 = typeof v268;
    const v270 = v269 === 'string';
    if (v270) {
        const v271 = options.baseFile;
        const v272 = fileUrl(v271);
        options.baseUrl = v272;
        const v273 = options.baseFile;
        const v274 = delete v273;
        v274;
    }
    const v275 = options.baseUrl;
    const v276 = !v275;
    if (v276) {
        const v277 = path.resolve(inputFilePath);
        const v278 = process.cwd();
        let v279;
        if (inputFilePath) {
            v279 = v277;
        } else {
            v279 = v278;
        }
        const v280 = fileUrl(v279);
        options.baseUrl = v280;
    }
    const v281 = options.height;
    const v282 = typeof v281;
    const v283 = v282 === 'string';
    if (v283) {
        const v284 = options.height;
        const v285 = parseInt(v284, 10);
        options.height = v285;
    }
    const v286 = options.rounding;
    const v287 = typeof v286;
    const v288 = v287 !== 'string';
    const v289 = [
        'ceil',
        'floor',
        'round'
    ];
    const v290 = options.rounding;
    const v291 = v289.includes(v290);
    const v292 = !v291;
    const v293 = v288 || v292;
    if (v293) {
        options.rounding = 'round';
    }
    const v294 = options.scale;
    const v295 = v294 == null;
    if (v295) {
        options.scale = 1;
    }
    const v296 = options.width;
    const v297 = typeof v296;
    const v298 = v297 === 'string';
    if (v298) {
        const v299 = options.width;
        const v300 = parseInt(v299, 10);
        options.width = v300;
    }
    const v301 = provider.parseAPIOptions(options, inputFilePath);
    v301;
    return options;
};
Converter._parseOptions = _parseOptions;
const _roundDimension = function _roundDimension(dimension, rounding) {
    switch (rounding) {
    case 'ceil':
        const v302 = Math.ceil(dimension);
        return v302;
    case 'floor':
        const v303 = Math.floor(dimension);
        return v303;
    case 'round':
    default:
        const v304 = Math.round(dimension);
        return v304;
    }
};
Converter._roundDimension = _roundDimension;
const _roundDimensions = function _roundDimensions(dimensions, rounding) {
    const v305 = dimensions.width;
    const v306 = this[_roundDimension](v305, rounding);
    const v307 = dimensions.height;
    const v308 = this[_roundDimension](v307, rounding);
    const v309 = {};
    v309.width = v306;
    v309.height = v308;
    return v309;
};
Converter._roundDimensions = _roundDimensions;
const _setDimensions = async function _setDimensions(page, dimensions) {
    const v310 = dimensions.width;
    const v311 = typeof v310;
    const v312 = v311 !== 'number';
    const v313 = dimensions.height;
    const v314 = typeof v313;
    const v315 = v314 !== 'number';
    const v316 = v312 && v315;
    if (v316) {
        return;
    }
    const v328 = ({width, height}) => {
        const el = document.querySelector('svg');
        const v317 = !el;
        if (v317) {
            return;
        }
        const v318 = typeof width;
        const v319 = v318 === 'number';
        if (v319) {
            const v320 = `${ width }px`;
            const v321 = el.setAttribute('width', v320);
            v321;
        } else {
            const v322 = el.removeAttribute('width');
            v322;
        }
        const v323 = typeof height;
        const v324 = v323 === 'number';
        if (v324) {
            const v325 = `${ height }px`;
            const v326 = el.setAttribute('height', v325);
            v326;
        } else {
            const v327 = el.removeAttribute('height');
            v327;
        }
    };
    await page.evaluate(v328, dimensions);
};
Converter._setDimensions = _setDimensions;
const _validate = function _validate() {
    const v329 = this[_destroyed];
    if (v329) {
        const v330 = new Error('Converter has been destroyed. A new Converter must be created');
        throw v330;
    }
};
Converter._validate = _validate;
const destroyed = function destroyed() {
    const v331 = this[_destroyed];
    return v331;
};
Converter.destroyed = destroyed;
const provider = function provider() {
    const v332 = this[_provider];
    return v332;
};
Converter.provider = provider;
Converter['is_class'] = true;
module.exports = Converter;